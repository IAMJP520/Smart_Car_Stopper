#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
HUD ë„¤ë¹„ê²Œì´ì…˜ í™”ë©´ (ì¹´ë©”ë¼ ë°°ê²½ í¬í•¨)
ESP32 ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¼ì„ ë°°ê²½ìœ¼ë¡œ í•˜ê³  ê·¸ ìœ„ì— HUD ì˜¤ë²„ë ˆì´
ZeroMQë¡œ ë©”ì¸ ì»¨íŠ¸ë¡¤ëŸ¬ë¡œë¶€í„° ì‹¤ì‹œê°„ ë°ì´í„° ìˆ˜ì‹ í•˜ì—¬
ê²½ë¡œ ì•ˆë‚´, ê±°ë¦¬ ì •ë³´, ìŒì„± ì•ˆë‚´ë¥¼ ì œê³µ
"""

import sys
import json
import threading
import tempfile
import os
import time
from datetime import datetime
from typing import Optional, Dict, Any

# OpenCV Qt í”ŒëŸ¬ê·¸ì¸ ì¶©ëŒ ë°©ì§€ (OpenCV import ì „ì— ì‹¤í–‰)
try:
    system_qt_paths = [
        '/usr/lib/x86_64-linux-gnu/qt5/plugins',
        '/usr/lib/qt5/plugins',
        '/usr/lib/qt/plugins'
    ]
    qt_plugin_path = None
    for path in system_qt_paths:
        if os.path.exists(path) and os.path.exists(os.path.join(path, 'platforms')):
            qt_plugin_path = path
            break
    if not qt_plugin_path:
        try:
            import PyQt5
            pyqt5_path = os.path.dirname(PyQt5.__file__)
            possible_paths = [
                os.path.join(pyqt5_path, 'Qt5', 'plugins'),
                os.path.join(os.path.dirname(pyqt5_path), 'PyQt5', 'Qt5', 'plugins')
            ]
            for path in possible_paths:
                if os.path.exists(path):
                    qt_plugin_path = path
                    break
        except:
            pass
    if qt_plugin_path:
        os.environ['QT_QPA_PLATFORM_PLUGIN_PATH'] = qt_plugin_path
except Exception as e:
    pass

os.environ['OPENCV_VIDEOIO_PRIORITY_MSMF'] = '0'
os.environ['OPENCV_VIDEOIO_DEBUG'] = '0'

import cv2

# OpenCVê°€ Qt í”ŒëŸ¬ê·¸ì¸ ê²½ë¡œë¥¼ ë®ì–´ì“´ ê²½ìš° ì¬ì„¤ì •
if 'QT_QPA_PLATFORM_PLUGIN_PATH' in os.environ:
    current_path = os.environ['QT_QPA_PLATFORM_PLUGIN_PATH']
    if 'cv2' in current_path or 'opencv' in current_path.lower():
        system_qt_paths_check = [
            '/usr/lib/x86_64-linux-gnu/qt5/plugins',
            '/usr/lib/qt5/plugins',
            '/usr/lib/qt/plugins'
        ]
        for path in system_qt_paths_check:
            if os.path.exists(path) and os.path.exists(os.path.join(path, 'platforms')):
                os.environ['QT_QPA_PLATFORM_PLUGIN_PATH'] = path
                break

import zmq
import pygame
from gtts import gTTS

from PyQt5.QtWidgets import (
    QApplication, QFrame, QPushButton, QWidget, QSizePolicy, QLabel
)
from PyQt5.QtGui import (
    QPainter, QColor, QBrush, QPen, QFont, QPolygonF,
    QLinearGradient, QRadialGradient, QFontMetrics, QImage, QPixmap
)
from PyQt5.QtCore import (
    Qt, QTimer, pyqtSignal, QObject, pyqtProperty, QEasingCurve,
    QPropertyAnimation, QPointF, QRectF, QThread
)

ESP32_CAM_URL = "http://192.168.0.29:81/stream"

# ===================================================================
# ê°œì„ ëœ í˜„ëŒ€ì°¨ ìŠ¤íƒ€ì¼ ì»¬ëŸ¬ íŒ”ë ˆíŠ¸ - Smart_Parking_GUI.pyì™€ ë™ì¼
# ===================================================================
HYUNDAI_COLORS = {
    'primary': '#1a1a1a',        # ì§„í•œ ì°¨ì½œ ê·¸ë ˆì´
    'secondary': "#2d2d2d",      # ë¯¸ë””ì—„ ê·¸ë ˆì´  
    'accent': '#4a9eff',         # ë¶€ë“œëŸ¬ìš´ ë¸”ë£¨
    'success': '#00d084',        # ë¯¼íŠ¸ ê·¸ë¦°
    'warning': '#ffa726',        # ì†Œí”„íŠ¸ ì˜¤ë Œì§€
    'danger': '#ef5350',         # ì†Œí”„íŠ¸ ë ˆë“œ
    'background': '#0f0f0f',     # ë” ê¹Šì€ ë¸”ë™
    'surface': '#1e1e1e',        # ë‹¤í¬ ì„œí˜ì´ìŠ¤
    'text_primary': '#ffffff',   # ìˆœë°±
    'text_secondary': '#9e9e9e', # ì¿¨ ê·¸ë ˆì´
    'glass': 'rgba(255, 255, 255, 0.08)',
    'blue_soft': '#6bb6ff',      # ì†Œí”„íŠ¸ ë¸”ë£¨
    'blue_muted': '#4285f4',     # ë®¤íŠ¸ ë¸”ë£¨
    'white_soft': '#f5f5f5',     # ì†Œí”„íŠ¸ í™”ì´íŠ¸
    'gray_light': '#757575',     # ë¼ì´íŠ¸ ê·¸ë ˆì´
    'gray_medium': '#424242'     # ë¯¸ë””ì—„ ê·¸ë ˆì´
}

FONT_SIZES = {
    'hud_distance': 84, 'hud_direction': 24, 'hud_speed': 56, 'hud_speed_unit': 20,
    'hud_progress': 28, 'hud_next_label': 20, 'hud_next_direction': 28,
    'map_label': 20, 'map_io_label': 24, 'map_waypoint_label': 24,
    'controls_title': 32, 'controls_info': 24, 'controls_button': 32, 'msgbox_button': 20
}

# ===================================================================
# TTS ìŒì„± ì•ˆë‚´ ëª¨ë“ˆ (Smart_Parking_GUI.pyì™€ ë™ì¼)
# ===================================================================
class VoiceGuide:
    """ìŒì„± ê²½ë¡œ ì•ˆë‚´ë¥¼ ë‹´ë‹¹í•˜ëŠ” í´ë˜ìŠ¤ (Google TTS ì‚¬ìš©)"""
    
    def __init__(self):
        self.last_instruction = None
        self.temp_files = []
        self.init_tts()
    
    def init_tts(self):
        """TTS ì—”ì§„ ì´ˆê¸°í™” (Google TTS ì‚¬ìš©)"""
        try:
            pygame.mixer.init()
            print("ğŸ”Š Google TTS ì—”ì§„ ì´ˆê¸°í™” ì™„ë£Œ")
        except Exception as e:
            print(f"âŒ TTS ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            self.engine = None
    
    def speak_instruction(self, instruction_text):
        """ìŒì„± ì•ˆë‚´ ì¬ìƒ"""
        if not instruction_text:
            return
        
        if self.last_instruction == instruction_text:
            return
        
        self.last_instruction = instruction_text
        
        try:
            threading.Thread(
                target=self._speak_thread,
                args=(instruction_text,),
                daemon=True,
                name="VoiceGuide"
            ).start()
        except Exception as e:
            print(f"âŒ ìŒì„± ì•ˆë‚´ ì¬ìƒ ì‹¤íŒ¨: {e}")
    
    def _speak_thread(self, text):
        """ìŒì„± ì¬ìƒ ìŠ¤ë ˆë“œ (Google TTS ì‚¬ìš©)"""
        try:
            tts = gTTS(text=text, lang='ko', slow=False)
            
            with tempfile.NamedTemporaryFile(delete=False, suffix='.mp3') as temp_file:
                temp_path = temp_file.name
                tts.save(temp_path)
                self.temp_files.append(temp_path)
            
            pygame.mixer.music.load(temp_path)
            pygame.mixer.music.play()
            
            while pygame.mixer.music.get_busy():
                pygame.time.wait(100)
            
            try:
                os.unlink(temp_path)
                if temp_path in self.temp_files:
                    self.temp_files.remove(temp_path)
            except:
                pass
            
            print(f"ğŸ”Š ìŒì„± ì•ˆë‚´: {text}")
            
        except Exception as e:
            print(f"âŒ ìŒì„± ì¬ìƒ ì¤‘ ì˜¤ë¥˜: {e}")
    
    def stop(self):
        """TTS ì—”ì§„ ì •ë¦¬"""
        try:
            pygame.mixer.quit()
            
            for temp_file in self.temp_files:
                try:
                    if os.path.exists(temp_file):
                        os.unlink(temp_file)
                except:
                    pass
            self.temp_files.clear()
            
            print("ğŸ”‡ TTS ì—”ì§„ ì •ë¦¬ ì™„ë£Œ")
        except Exception as e:
            print(f"âŒ TTS ì •ë¦¬ ì¤‘ ì˜¤ë¥˜: {e}")

# ===================================================================
# ZeroMQ ë°ì´í„° ìˆ˜ì‹ ê¸° í´ë˜ìŠ¤
# ===================================================================
class HUDDataReceiver(QObject):
    """HUDìš© ZeroMQ ë°ì´í„° ìˆ˜ì‹ ê¸°"""
    
    position_received = pyqtSignal(dict)
    navigation_received = pyqtSignal(dict)
    waypoint_received = pyqtSignal(dict)
    payment_received = pyqtSignal(dict)  # ì •ì‚° ê¸ˆì•¡ ìˆ˜ì‹  ì‹œê·¸ë„ ì¶”ê°€
    
    def __init__(self, zmq_host='localhost', zmq_port=5555):
        super().__init__()
        self.zmq_host = zmq_host
        self.zmq_port = zmq_port
        self.context = None
        self.socket = None
        self.running = False
        
    def start(self):
        """ZeroMQ êµ¬ë… ì‹œì‘"""
        try:
            self.context = zmq.Context()
            self.socket = self.context.socket(zmq.SUB)
            self.socket.connect(f"tcp://{self.zmq_host}:{self.zmq_port}")
            
            self.socket.setsockopt_string(zmq.SUBSCRIBE, "vehicle_position")
            self.socket.setsockopt_string(zmq.SUBSCRIBE, "navigation_instruction")
            self.socket.setsockopt_string(zmq.SUBSCRIBE, "waypoint_data")
            self.socket.setsockopt_string(zmq.SUBSCRIBE, "payment_data")  # ì •ì‚° ë°ì´í„° êµ¬ë… ì¶”ê°€
            
            self.socket.setsockopt(zmq.RCVTIMEO, 100)
            
            self.running = True
            print(f"âœ… HUD ZeroMQ êµ¬ë… ì‹œì‘ë¨ - {self.zmq_host}:{self.zmq_port}")
            
            threading.Thread(target=self._receive_loop, daemon=True, name="HUDZMQReceiver").start()
            return True
            
        except Exception as e:
            print(f"âŒ HUD ZeroMQ êµ¬ë… ì‹œì‘ ì‹¤íŒ¨: {e}")
            return False
    
    def _receive_loop(self):
        """ë°ì´í„° ìˆ˜ì‹  ë£¨í”„"""
        while self.running:
            try:
                message = self.socket.recv_string(zmq.NOBLOCK)
                self._process_message(message)
                
            except zmq.Again:
                continue
            except Exception as e:
                if self.running:
                    print(f"âŒ HUD ZeroMQ ë©”ì‹œì§€ ìˆ˜ì‹  ì˜¤ë¥˜: {e}")
                break
    
    def _process_message(self, message: str):
        """ìˆ˜ì‹ ëœ ë©”ì‹œì§€ ì²˜ë¦¬"""
        try:
            parts = message.split(' ', 1)
            if len(parts) != 2:
                return
                
            topic, json_data = parts
            data = json.loads(json_data)
            
            if topic == "vehicle_position":
                self.position_received.emit(data)
            elif topic == "navigation_instruction":
                self.navigation_received.emit(data)
            elif topic == "waypoint_data":
                self.waypoint_received.emit(data)
            elif topic == "payment_data":
                self.payment_received.emit(data)  # ì •ì‚° ë°ì´í„° ì²˜ë¦¬
                
        except Exception as e:
            print(f"âŒ HUD ë©”ì‹œì§€ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
    
    def stop(self):
        """ZeroMQ êµ¬ë… ì¢…ë£Œ"""
        self.running = False
        if self.socket:
            self.socket.close()
        if self.context:
            self.context.term()
        print("ğŸ”„ HUD ZeroMQ êµ¬ë… ì¢…ë£Œë¨")

# ===================================================================
# ESP32 ì¹´ë©”ë¼ ë¹„ë””ì˜¤ ìŠ¤íŠ¸ë¦¼ ìŠ¤ë ˆë“œ
# ===================================================================
class VideoThread(QThread):
    """ESP32 ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¼ ìˆ˜ì‹  ìŠ¤ë ˆë“œ"""
    change_pixmap_signal = pyqtSignal(QImage)
    connection_status_signal = pyqtSignal(str)
    error_signal = pyqtSignal(str)
    
    def __init__(self, url):
        super().__init__()
        self.url = url
        self._run_flag = True
        self.cap = None
        self.reconnect_delay = 2.0
        self.max_reconnect_attempts = 10
        self.reconnect_count = 0
        self.frame_timeout = 5.0
        self.last_frame_time = None
        self.fps_target = 30
        self.frame_interval = 1.0 / self.fps_target
        self.last_frame_received = time.time()
        
    def _initialize_capture(self):
        """ë¹„ë””ì˜¤ ìº¡ì²˜ ê°ì²´ ì´ˆê¸°í™”"""
        try:
            if self.cap:
                self.cap.release()
            
            self.cap = cv2.VideoCapture(self.url)
            self.cap.set(cv2.CAP_PROP_BUFFERSIZE, 1)
            self.cap.set(cv2.CAP_PROP_FRAME_WIDTH, 640)
            self.cap.set(cv2.CAP_PROP_FRAME_HEIGHT, 480)
            self.cap.set(cv2.CAP_PROP_AUTO_EXPOSURE, 0.25)
            self.cap.set(cv2.CAP_PROP_FPS, 30)
            
            if self.cap.isOpened():
                self.connection_status_signal.emit("ì—°ê²°ë¨")
                self.reconnect_count = 0
                print(f"âœ… ESP32 ì¹´ë©”ë¼ ì—°ê²° ì„±ê³µ: {self.url}")
                return True
            else:
                self.connection_status_signal.emit("ì—°ê²° ì‹¤íŒ¨")
                print(f"âŒ ESP32 ì¹´ë©”ë¼ ì—°ê²° ì‹¤íŒ¨: {self.url}")
                return False
                
        except Exception as e:
            self.connection_status_signal.emit("ì—°ê²° ì˜¤ë¥˜")
            self.error_signal.emit(f"ì´ˆê¸°í™” ì˜¤ë¥˜: {str(e)}")
            print(f"âŒ ë¹„ë””ì˜¤ ìº¡ì²˜ ì´ˆê¸°í™” ì˜¤ë¥˜: {e}")
            return False
    
    def run(self):
        """ë©”ì¸ ìŠ¤ë ˆë“œ ë£¨í”„"""
        while self._run_flag:
            if self.cap is None or not self.cap.isOpened():
                if not self._try_reconnect():
                    self.msleep(int(self.reconnect_delay * 1000))
                    continue
            
            try:
                ret, frame = None, None
                for _ in range(2):
                    temp_ret, temp_frame = self.cap.read()
                    if temp_ret and temp_frame is not None:
                        ret, frame = temp_ret, temp_frame
                    else:
                        break
                
                if ret and frame is not None:
                    self.last_frame_time = time.time()
                    self.last_frame_received = time.time()
                    self.reconnect_count = 0
                    
                    try:
                        rgb_image = cv2.cvtColor(frame, cv2.COLOR_BGR2RGB)
                        h, w, ch = rgb_image.shape
                        bytes_per_line = ch * w
                        qt_image = QImage(rgb_image.copy(), w, h, bytes_per_line, QImage.Format_RGB888)
                        self.change_pixmap_signal.emit(qt_image)
                    except Exception as e:
                        print(f"âš ï¸ ì´ë¯¸ì§€ ë³€í™˜ ì˜¤ë¥˜: {e}")
                        self.msleep(10)
                else:
                    self._handle_frame_read_error()
                    
            except Exception as e:
                print(f"âŒ í”„ë ˆì„ ì½ê¸° ì˜¤ë¥˜: {e}")
                self.error_signal.emit(f"í”„ë ˆì„ ì½ê¸° ì˜¤ë¥˜: {str(e)}")
                self.cap = None
                self.msleep(int(self.reconnect_delay * 1000))
            
            current_time = time.time()
            elapsed = current_time - self.last_frame_received if self.last_frame_received else 0
            sleep_time = max(0, (self.frame_interval - elapsed) * 1000)
            if sleep_time > 0:
                self.msleep(int(sleep_time))
            self.last_frame_received = time.time()
        
        self._cleanup()
    
    def _try_reconnect(self):
        """ì¬ì—°ê²° ì‹œë„"""
        if self.reconnect_count >= self.max_reconnect_attempts:
            self.connection_status_signal.emit("ì¬ì—°ê²° ì‹¤íŒ¨")
            self.error_signal.emit(f"ìµœëŒ€ ì¬ì—°ê²° ì‹œë„ íšŸìˆ˜({self.max_reconnect_attempts}) ì´ˆê³¼")
            print(f"âŒ ìµœëŒ€ ì¬ì—°ê²° ì‹œë„ íšŸìˆ˜ ì´ˆê³¼: {self.max_reconnect_attempts}")
            return False
        
        self.reconnect_count += 1
        self.connection_status_signal.emit(f"ì¬ì—°ê²° ì‹œë„ ì¤‘... ({self.reconnect_count}/{self.max_reconnect_attempts})")
        print(f"ğŸ”„ ì¬ì—°ê²° ì‹œë„ {self.reconnect_count}/{self.max_reconnect_attempts}...")
        return self._initialize_capture()
    
    def _handle_frame_read_error(self):
        """í”„ë ˆì„ ì½ê¸° ì˜¤ë¥˜ ì²˜ë¦¬"""
        if self.last_frame_time:
            time_since_last_frame = time.time() - self.last_frame_time
            if time_since_last_frame > self.frame_timeout:
                print(f"âš ï¸ í”„ë ˆì„ ìˆ˜ì‹  íƒ€ì„ì•„ì›ƒ ({time_since_last_frame:.1f}ì´ˆ)")
                self.cap = None
                return
        self.msleep(100)
    
    def _cleanup(self):
        """ë¦¬ì†ŒìŠ¤ ì •ë¦¬"""
        try:
            if self.cap:
                self.cap.release()
                self.cap = None
            print("ğŸ§¹ ë¹„ë””ì˜¤ ìº¡ì²˜ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ ì™„ë£Œ")
        except Exception as e:
            print(f"âš ï¸ ì •ë¦¬ ì¤‘ ì˜¤ë¥˜: {e}")
    
    def stop(self):
        """ìŠ¤ë ˆë“œ ì¢…ë£Œ"""
        self._run_flag = False
        self.wait()
    
    def update_url(self, new_url):
        """URL ì—…ë°ì´íŠ¸"""
        self.url = new_url
        if self.cap:
            self.cap.release()
            self.cap = None
        print(f"ğŸ”„ URL ì—…ë°ì´íŠ¸: {new_url}")

# ===================================================================
# ì• ë‹ˆë©”ì´ì…˜ HUD ìœ„ì ¯: Smart_Parking_GUI.pyì˜ PremiumHudWidget ìŠ¤íƒ€ì¼
# ===================================================================
class PremiumHudWidget(QFrame):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setFrameShape(QFrame.NoFrame)
        # ìµœì†Œ í¬ê¸° ì„¤ì • ì œê±° (ë¶€ëª¨ í¬ê¸°ì— ë§ì¶¤)
        self.setMinimumSize(100, 100)  # ìµœì†Œ í¬ê¸°ë§Œ ì„¤ì •
        # ì°½ í¬ê¸°ì— ë§ì¶° í™•ì¥ë˜ë„ë¡ ì„¤ì •
        self.setSizePolicy(QSizePolicy.Expanding, QSizePolicy.Expanding)
        # ë°°ê²½ì„ íˆ¬ëª…í•˜ê²Œ ì„¤ì • (ì¹´ë©”ë¼ í™”ë©´ì´ ë³´ì´ë„ë¡)
        self.setStyleSheet(f"""
            PremiumHudWidget {{
                background: transparent;
                border: none;
            }}
        """)
        # íˆ¬ëª… ë°°ê²½ ì„¤ì •
        self.setAttribute(Qt.WA_TranslucentBackground, True)
        # ë§ˆìš°ìŠ¤ ì´ë²¤íŠ¸ë¥¼ ë’¤ë¡œ ì „ë‹¬ (ì¹´ë©”ë¼ ì˜ì—­ í´ë¦­ ê°€ëŠ¥í•˜ë„ë¡)
        self.setAttribute(Qt.WA_TransparentForMouseEvents, False)
        self.current_direction = "ê²½ë¡œ ì„¤ì • ëŒ€ê¸°"
        self.current_distance = 0.0
        self.next_direction = ""
        self.speed = 0
        self.progress = 0
        self.animation_timer = QTimer(self)
        self.animation_timer.timeout.connect(self.update_animation)
        self.animation_timer.start(50)
        self.rotation_angle = 0
        self.pulse_scale = 1.0
        self.pulse_growing = True
        self.glow_opacity = 0.3
        self.glow_increasing = True
        import random
        self.particle_positions = []
        self.init_particles()
        self.direction_transition = 0.0
        self.target_direction = "ì§ì§„"
        self.previous_direction = "ì§ì§„"
        
        self.voice_guide = VoiceGuide()
        
        # ì¶œì°¨ ì‹œì‘ ë²„íŠ¼ (ìš°ì¸¡ í•˜ë‹¨, ì‘ê²Œ)
        # Smart_Parking_GUI.py ìŠ¤íƒ€ì¼ ì°¸ê³ : ì‘ì€ í¬ê¸° (350x40 -> ë” ì‘ê²Œ 250x35)
        self.exit_scenario_button = QPushButton("ì¶œì°¨ ì‹œì‘", self)
        self.exit_scenario_button.setStyleSheet(f"""
            QPushButton {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {HYUNDAI_COLORS['accent']}, 
                    stop:1 {HYUNDAI_COLORS['blue_muted']});
                color: {HYUNDAI_COLORS['text_primary']};
                border: 2px solid {HYUNDAI_COLORS['blue_soft']};
                border-radius: 18px;
                font-size: 14px;
                font-weight: bold;
                font-family: 'Malgun Gothic';
            }}
            QPushButton:hover {{
                background: qlineargradient(x1:0, y1:0, x2:0, y2:1,
                    stop:0 {HYUNDAI_COLORS['blue_soft']}, 
                    stop:1 {HYUNDAI_COLORS['accent']});
                border: 2px solid {HYUNDAI_COLORS['text_primary']};
            }}
            QPushButton:pressed {{
                background: {HYUNDAI_COLORS['blue_muted']};
                border: 2px solid {HYUNDAI_COLORS['warning']};
            }}
        """)
        self.exit_scenario_button.clicked.connect(self.start_exit_scenario)

    def init_particles(self):
        import random
        self.particle_positions = []
        for _ in range(8):
            # ì°½ í¬ê¸°ì— ë§ì¶° ë™ì ìœ¼ë¡œ íŒŒí‹°í´ ë²”ìœ„ ì„¤ì •
            self.particle_positions.append({
                'x': random.randint(0, 900), 'y': random.randint(0, 1100),
                'speed': random.uniform(0.3, 1.0), 'size': random.randint(2, 6),
                'opacity': random.uniform(0.05, 0.15)
            })
    
    def resizeEvent(self, event):
        """ì°½ í¬ê¸° ë³€ê²½ ì‹œ íŒŒí‹°í´ ë²”ìœ„ë„ ì—…ë°ì´íŠ¸ ë° ë²„íŠ¼ ìœ„ì¹˜ ì¡°ì •"""
        super().resizeEvent(event)
        import random
        width = self.width()
        height = self.height()
        
        # íŒŒí‹°í´ ë²”ìœ„ ì—…ë°ì´íŠ¸
        for particle in self.particle_positions:
            if particle['x'] > width:
                particle['x'] = random.randint(0, width) if width > 0 else 900
            if particle['y'] > height:
                particle['y'] = random.randint(0, height) if height > 0 else 1100
        
        # ì¶œì°¨ ë²„íŠ¼ ìœ„ì¹˜: ìš°ì¸¡ í•˜ë‹¨ (ì—¬ìœ  ê³µê°„ 20px)
        button_width = 250
        button_height = 35
        button_x = width - button_width - 20
        button_y = height - button_height - 20
        self.exit_scenario_button.setGeometry(button_x, button_y, button_width, button_height)

    def update_animation(self):
        self.rotation_angle = (self.rotation_angle + 1) % 360
        if self.pulse_growing:
            self.pulse_scale += 0.01
            if self.pulse_scale >= 1.05: self.pulse_growing = False
        else:
            self.pulse_scale -= 0.01
            if self.pulse_scale <= 1.0: self.pulse_growing = True
        if self.glow_increasing:
            self.glow_opacity += 0.02
            if self.glow_opacity >= 0.4: self.glow_increasing = False
        else:
            self.glow_opacity -= 0.02
            if self.glow_opacity <= 0.2: self.glow_increasing = True
        for particle in self.particle_positions:
            particle['y'] -= particle['speed']
            if particle['y'] < 0:
                import random
                width = self.width() if self.width() > 0 else 900
                height = self.height() if self.height() > 0 else 1100
                particle['y'] = height
                particle['x'] = random.randint(0, width)
        if self.direction_transition < 1.0:
            self.direction_transition = min(1.0, self.direction_transition + 0.1)
        self.update()

    def paintEvent(self, event):
        super().paintEvent(event)
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)
        painter.setRenderHint(QPainter.SmoothPixmapTransform)
        rect, center_x = self.rect(), self.rect().width() // 2
        height = rect.height()
        
        # ì°½ í¬ê¸°ì— ë§ì¶° ë™ì ìœ¼ë¡œ ë°°ì¹˜ (í™”ë©´ í•˜ë‹¨ ì ˆë°˜ì— ë°°ì¹˜, í¬ê¸° ë°˜ìœ¼ë¡œ ì¶•ì†Œ)
        self.draw_background_effects(painter, rect)
        
        # ì „ì²´ ìš”ì†Œ í¬ê¸° ì¡°ì • (0.6 ìŠ¤ì¼€ì¼ = ì›ë˜ í¬ê¸°ì˜ 60%, í™”ë©´ í•˜ë‹¨ ì ˆë°˜ì— ë°°ì¹˜)
        painter.save()
        painter.scale(0.6, 0.6)
        # ìŠ¤ì¼€ì¼ ì ìš© í›„ ì¢Œí‘œ ê³„ì‚° (0.6 ìŠ¤ì¼€ì¼ì´ë¯€ë¡œ ì•½ 1.67ë°°ë¡œ í™•ëŒ€)
        center_x_scaled = center_x / 0.6
        height_scaled = height / 0.6
        
        # í™”ë©´ í•˜ë‹¨ ì ˆë°˜ ì˜ì—­ì— ë°°ì¹˜ (í™”ë©´ ë†’ì´ì˜ ì ˆë°˜ ì§€ì ë¶€í„° í•˜ë‹¨ê¹Œì§€)
        half_height = height_scaled / 2
        bottom_margin = height_scaled / 6  # í•˜ë‹¨ ì—¬ìœ  ê³µê°„ (í™”ë©´ì˜ 1/6)
        
        # ì†ë„ ê²Œì´ì§€: í™”ë©´ í•˜ë‹¨ ì ˆë°˜ ì˜ì—­ ë‚´ì—ì„œ í•˜ë‹¨ ê·¼ì²˜ì— ë°°ì¹˜
        # í™”ë©´ ì ˆë°˜ ì§€ì (half_height) ì•„ë˜ ì˜ì—­ ë‚´ì—ì„œ í•˜ë‹¨ ì—¬ìœ  ê³µê°„ í™•ë³´
        speed_y_scaled = height_scaled - bottom_margin - 80  # í•˜ë‹¨ì—ì„œ ìœ„ë¡œ 280px
        
        # í™”ë©´ ì ˆë°˜ ì•„ë˜ ì˜ì—­ ë‚´ì— ë°°ì¹˜ë˜ë„ë¡ ë³´ì¥
        if speed_y_scaled < half_height:
            # ìš”ì†Œê°€ ë„ˆë¬´ ìœ„ì— ìˆìœ¼ë©´ í•˜ë‹¨ ì ˆë°˜ ì˜ì—­ ë‚´ë¡œ ì¡°ì •
            speed_y_scaled = half_height + (height_scaled - half_height - bottom_margin - 80)
        
        self.draw_speed_gauge(painter, center_x_scaled, speed_y_scaled)
        
        # ê±°ë¦¬ íŒ¨ë„: ì†ë„ ê²Œì´ì§€ ìœ„ì— ë°°ì¹˜ (ê²Œì´ì§€ ìƒë‹¨ì—ì„œ ìœ„ë¡œ 230px)
        distance_y_scaled = speed_y_scaled - 230
        self.draw_distance_panel(painter, center_x_scaled, distance_y_scaled)
        
        # ë°©í–¥ í‘œì‹œ: ê±°ë¦¬ íŒ¨ë„ ìœ„ì— ë°°ì¹˜ (íŒ¨ë„ ìƒë‹¨ì—ì„œ ìœ„ë¡œ 320px)
        direction_y_scaled = distance_y_scaled - 320
        self.draw_3d_direction_display(painter, center_x_scaled, direction_y_scaled)
        
        # ë‹¤ìŒ ì•ˆë‚´ ì¹´ë“œ: ì†ë„ ê²Œì´ì§€ ì•„ë˜ì— ë°°ì¹˜ (í™”ë©´ ë°–ì¼ ìˆ˜ ìˆìŒ)
        next_y_scaled = speed_y_scaled + 200
        self.draw_next_instruction_card(painter, center_x_scaled, next_y_scaled)
        
        painter.restore()
        
        self.draw_decorative_elements(painter, rect)

    def draw_background_effects(self, painter, rect):
        painter.save()
        for particle in self.particle_positions:
            # íŒŒí‹°í´ì´ í™”ë©´ ë‚´ì— ìˆëŠ”ì§€ í™•ì¸
            if 0 <= particle['x'] <= rect.width() and 0 <= particle['y'] <= rect.height():
                color = QColor(HYUNDAI_COLORS['blue_soft'])
                color.setAlphaF(particle['opacity'])
                painter.setBrush(QBrush(color))
                painter.setPen(Qt.NoPen)
                painter.drawEllipse(QPointF(particle['x'], particle['y']), particle['size'], particle['size'])
        painter.restore()

    def draw_3d_direction_display(self, painter, center_x, y):
        painter.save()
        painter.translate(center_x, y)
        
        # ë°°ê²½ ì›í˜• ëª¨ë‘ ì œê±° - í™”ì‚´í‘œë§Œ í‘œì‹œ
        # ì „ì²´ ìŠ¤ì¼€ì¼ì´ 0.6ì´ë¯€ë¡œ í™”ì‚´í‘œë¥¼ 2ë°°ë¡œ í‚¤ìš°ë ¤ë©´ ì•½ 3.33ë°° ì ìš©
        painter.scale(self.pulse_scale * 3.33, self.pulse_scale * 3.33)
        
        self.draw_3d_direction_icon(painter)
        
        # save/restoreê°€ ìë™ìœ¼ë¡œ scaleì„ ë˜ëŒë ¤ì¤Œ
        painter.restore()

    def draw_3d_direction_icon(self, painter):
        painter.save()
        painter.setPen(Qt.NoPen)
        
        # ê²€ì • ë°°ê²½(ê·¸ë¦¼ì) ì œê±° - í™”ì‚´í‘œë§Œ ê·¸ë¦¬ê¸°
        action = None

        if "ì¢ŒíšŒì „" in self.current_direction:
            action = self.draw_3d_left_arrow
        elif "ìš°íšŒì „" in self.current_direction:
            action = self.draw_3d_right_arrow
        elif "ëª©ì ì§€" in self.current_direction:
            action = self.draw_3d_destination_icon
        elif "ì¶œì°¨ ì™„ë£Œ" in self.current_direction:
            action = self.draw_3d_exit_complete_icon

        if action:
            # íŒŒë€ìƒ‰ í™”ì‚´í‘œë¡œ ê·¸ë¦¬ê¸°
            painter.setBrush(QBrush(QColor(HYUNDAI_COLORS['blue_soft'])))
            painter.setPen(QPen(QColor(HYUNDAI_COLORS['blue_soft']), 4))  # scale ì ìš©ë˜ë¯€ë¡œ ì›ë˜ ë‘ê»˜
            action(painter, 0, 0)
        else:
            self.draw_3d_straight_arrow(painter, 0, 0)
        painter.restore()

    def draw_3d_left_arrow(self, painter, x, y, shadow=False):
        # scaleì´ 2ë°°ë¡œ ì ìš©ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ì›ë˜ ì¢Œí‘œ ì‚¬ìš©
        painter.drawPolygon(QPolygonF([
            QPointF(x-70, y),
            QPointF(x-30, y-40),
            QPointF(x-30, y-20),
            QPointF(x+40, y-20),
            QPointF(x+40, y+20),
            QPointF(x-30, y+20),
            QPointF(x-30, y+40)
        ]))

    def draw_3d_right_arrow(self, painter, x, y, shadow=False):
        # scaleì´ 2ë°°ë¡œ ì ìš©ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ì›ë˜ ì¢Œí‘œ ì‚¬ìš©
        painter.drawPolygon(QPolygonF([
            QPointF(x+70, y),
            QPointF(x+30, y-40),
            QPointF(x+30, y-20),
            QPointF(x-40, y-20),
            QPointF(x-40, y+20),
            QPointF(x+30, y+20),
            QPointF(x+30, y+40)
        ]))

    def draw_3d_straight_arrow(self, painter, x, y):
        # ê²€ì • ë°°ê²½(ê·¸ë¦¼ì) ì œê±° - íŒŒë€ìƒ‰ í™”ì‚´í‘œë§Œ ê·¸ë¦¬ê¸°
        # scaleì´ 2ë°°ë¡œ ì ìš©ë˜ì–´ ìˆìœ¼ë¯€ë¡œ ì›ë˜ ì¢Œí‘œ ì‚¬ìš©
        painter.setPen(Qt.NoPen)
        painter.setBrush(QBrush(QColor(HYUNDAI_COLORS['blue_soft'])))
        painter.setPen(QPen(QColor(HYUNDAI_COLORS['blue_soft']), 4))  # scale ì ìš©ë˜ë¯€ë¡œ ì›ë˜ ë‘ê»˜ ì‚¬ìš©
        painter.drawPolygon(QPolygonF([
            QPointF(x, y-70),
            QPointF(x-36, y-20),
            QPointF(x-20, y-20),
            QPointF(x-20, y+50),
            QPointF(x+20, y+50),
            QPointF(x+20, y-20),
            QPointF(x+36, y-20)
        ]))

    def draw_3d_destination_icon(self, painter, x, y, shadow=False):
        # ëª©ì ì§€ ë„ì°©: ì£¼í™©ìƒ‰ ì›ì— ì²´í¬ë§ˆí¬ í‘œì‹œ (SmartParking UI ì°¸ê³ )
        if shadow:
            painter.drawEllipse(QPointF(x, y), 50, 50)
        else:
            # ì£¼í™©ìƒ‰ ì› ê·¸ë¦¬ê¸°
            painter.setBrush(QBrush(QColor(HYUNDAI_COLORS['warning'])))  # ì£¼í™©ìƒ‰
            painter.setPen(QPen(QColor(HYUNDAI_COLORS['warning']), 4))
            painter.drawEllipse(QPointF(x, y), 50, 50)
            
            # ì²´í¬ë§ˆí¬ ê·¸ë¦¬ê¸° (í°ìƒ‰)
            painter.setPen(QPen(QColor(HYUNDAI_COLORS['white_soft']), 6))
            painter.setBrush(Qt.NoBrush)
            # ì²´í¬ë§ˆí¬ ë¼ì¸
            painter.drawLine(QPointF(x-16, y), QPointF(x-4, y+12))
            painter.drawLine(QPointF(x-4, y+12), QPointF(x+16, y-12))

    def draw_3d_exit_complete_icon(self, painter, x, y, shadow=False):
        # ì¶œì°¨ ì™„ë£Œ: ì£¼í™©ìƒ‰ ì›ì— ì²´í¬ë§ˆí¬ í‘œì‹œ (SmartParking UI ì°¸ê³ )
        if shadow:
            painter.drawEllipse(QPointF(x, y), 50, 50)
        else:
            # ì£¼í™©ìƒ‰ ì› ê·¸ë¦¬ê¸°
            painter.setBrush(QBrush(QColor(HYUNDAI_COLORS['warning'])))  # ì£¼í™©ìƒ‰
            painter.setPen(QPen(QColor(HYUNDAI_COLORS['warning']), 4))
            painter.drawEllipse(QPointF(x, y), 50, 50)
            
            # ì²´í¬ë§ˆí¬ ê·¸ë¦¬ê¸° (í°ìƒ‰)
            painter.setPen(QPen(QColor(HYUNDAI_COLORS['white_soft']), 6))
            painter.setBrush(Qt.NoBrush)
            # ì²´í¬ë§ˆí¬ ë¼ì¸
            painter.drawLine(QPointF(x-16, y), QPointF(x-4, y+12))
            painter.drawLine(QPointF(x-4, y+12), QPointF(x+16, y-12))

    def draw_distance_panel(self, painter, center_x, y):
        painter.save()
        # ë°°ê²½ ë°•ìŠ¤ ì œê±° - í…ìŠ¤íŠ¸ë§Œ í‘œì‹œ
        
        distance_text = f"{self.current_distance:.0f}m" if self.current_distance < 1000 else f"{self.current_distance/1000:.1f}km"
        # ê¸€ì í¬ê¸° í‚¤ìš°ê¸° (1.2ë°°)
        font_size = int(FONT_SIZES['hud_distance'] * 1.2)
        font = QFont("Segoe UI", font_size, QFont.Bold)
        painter.setFont(font)
        
        if self.current_distance <= 5:
            text_color = QColor(HYUNDAI_COLORS['warning'])
        elif self.current_distance <= 20:
            text_color = QColor(HYUNDAI_COLORS['success'])
        elif "ì¶œì°¨ ì™„ë£Œ" in self.current_direction or "ëª©ì ì§€ ë„ì°©" in self.current_direction:
            text_color = QColor(HYUNDAI_COLORS['warning'])
        else:
            text_color = QColor(HYUNDAI_COLORS['blue_soft'])
            
        # ìˆ«ìëŠ” ì¡°ê¸ˆ ìœ„ë¡œ ì´ë™
        painter.setPen(QPen(text_color))
        painter.drawText(QRectF(center_x-300, y-80, 600, 120), Qt.AlignCenter, distance_text)  # y-60 -> y-80 (ìœ„ë¡œ 20px)
        
        # ë°©í–¥ í…ìŠ¤íŠ¸ í¬ê¸° í‚¤ìš°ê¸° (1.2ë°°)
        direction_font_size = int(FONT_SIZES['hud_direction'] * 1.2)
        font = QFont("Malgun Gothic", direction_font_size, QFont.Bold)
        painter.setFont(font)
        painter.setPen(QPen(QColor(HYUNDAI_COLORS['text_secondary'])))
        direction_text = self.current_direction[:20] + "..." if len(self.current_direction)>20 else self.current_direction
        
        # "ì¶œì°¨ ì™„ë£Œ", "ëª©ì ì§€ ë„ì°©" ê°™ì€ ë‹¨ì–´ëŠ” ì¡°ê¸ˆ ì•„ë˜ë¡œ ì´ë™í•˜ê³  ê°„ê²© í™•ë³´
        if "ì¶œì°¨ ì™„ë£Œ" in self.current_direction or "ëª©ì ì§€ ë„ì°©" in self.current_direction:
            # ë‹¨ì–´ëŠ” ì•„ë˜ë¡œ ì´ë™ (y+20 -> y+60, ê°„ê²© 40px ì¶”ê°€)
            painter.drawText(QRectF(center_x-300, y+60, 600, 100), Qt.AlignCenter, direction_text)
        else:
            # ì¼ë°˜ í…ìŠ¤íŠ¸ë„ ê°„ê²© í™•ë³´
            painter.drawText(QRectF(center_x-300, y+40, 600, 100), Qt.AlignCenter, direction_text)
        painter.restore()

    def draw_speed_gauge(self, painter, center_x, y):
        painter.save()
        gauge_rect = QRectF(center_x - 160, y - 80, 320, 160)
        
        painter.setPen(QPen(QColor(HYUNDAI_COLORS['gray_medium']), 12))
        painter.setBrush(Qt.NoBrush)
        painter.drawArc(gauge_rect, 0, 180 * 16)
        
        speed_angle = min(180, (self.speed / 100) * 180)
        if "ì¶œì°¨ ì™„ë£Œ" in self.current_direction or "ëª©ì ì§€ ë„ì°©" in self.current_direction:
            painter.setPen(QPen(QColor(HYUNDAI_COLORS['warning']), 12))
        else:
            painter.setPen(QPen(QColor(HYUNDAI_COLORS['blue_soft']), 12))
        painter.drawArc(gauge_rect, 0, int(speed_angle * 16))
        
        font = QFont("Segoe UI", FONT_SIZES['hud_speed'], QFont.Bold)
        painter.setFont(font)
        painter.setPen(QPen(QColor(HYUNDAI_COLORS['text_primary'])))
        painter.drawText(QRectF(center_x-160, y-40, 320, 80), Qt.AlignCenter, f"{self.speed}")
        
        font = QFont("Malgun Gothic", FONT_SIZES['hud_speed_unit'])
        painter.setFont(font)
        painter.setPen(QPen(QColor(HYUNDAI_COLORS['text_secondary'])))
        painter.drawText(QRectF(center_x-160, y+20, 320, 40), Qt.AlignCenter, "km/h")
        painter.restore()

    def draw_next_instruction_card(self, painter, center_x, y):
        if not self.next_direction: return
        painter.save()
        card_rect = QRectF(center_x-400, y-80, 800, 160)
        
        painter.setBrush(QBrush(QColor(HYUNDAI_COLORS['surface'])))
        painter.setPen(QPen(QColor(HYUNDAI_COLORS['gray_medium']), 2))
        painter.drawRoundedRect(card_rect, 40, 40)
        
        font = QFont("Malgun Gothic", FONT_SIZES['hud_next_label'], QFont.Bold)
        painter.setFont(font)
        painter.setPen(QPen(QColor(HYUNDAI_COLORS['blue_soft'])))
        painter.drawText(QPointF(center_x-380, y-30), "ë‹¤ìŒ")
        
        icon_x, icon_y = center_x - 280, y + 20
        painter.setBrush(QBrush(QColor(HYUNDAI_COLORS['gray_medium'])))
        painter.setPen(QPen(QColor(HYUNDAI_COLORS['blue_soft']), 2))
        painter.drawEllipse(QPointF(icon_x, icon_y), 50, 50)
        
        painter.setPen(QPen(QColor(HYUNDAI_COLORS['white_soft']), 4))
        painter.setBrush(QBrush(QColor(HYUNDAI_COLORS['white_soft'])))
        if "ì¢ŒíšŒì „" in self.next_direction:
            self.draw_mini_left_arrow(painter, icon_x, icon_y)
        elif "ìš°íšŒì „" in self.next_direction:
            self.draw_mini_right_arrow(painter, icon_x, icon_y)
        elif "ëª©ì ì§€" in self.next_direction or "ë„ì°©" in self.next_direction:
            self.draw_mini_destination(painter, icon_x, icon_y)
        elif "ì¶œì°¨ ì™„ë£Œ" in self.next_direction:
            self.draw_mini_exit_complete(painter, icon_x, icon_y)
        else:
            self.draw_mini_straight(painter, icon_x, icon_y)
        
        font.setPointSize(FONT_SIZES['hud_next_direction'])
        painter.setFont(font)
        painter.setPen(QPen(QColor(HYUNDAI_COLORS['text_secondary'])))
        painter.drawText(QRectF(icon_x+60, y-40, 400, 120), Qt.AlignVCenter, 
                        self.next_direction[:20]+"..." if len(self.next_direction)>20 else self.next_direction)
        painter.restore()

    def draw_mini_left_arrow(self, painter, x, y): 
        painter.drawPolygon(QPolygonF([QPointF(x-24,y),QPointF(x-10,y-14),QPointF(x-10,y-6),QPointF(x+16,y-6),QPointF(x+16,y+6),QPointF(x-10,y+6),QPointF(x-10,y+14)]))
    def draw_mini_right_arrow(self, painter, x, y): 
        painter.drawPolygon(QPolygonF([QPointF(x+24,y),QPointF(x+10,y-14),QPointF(x+10,y-6),QPointF(x-16,y-6),QPointF(x-16,y+6),QPointF(x+10,y+6),QPointF(x+10,y+14)]))
    def draw_mini_straight(self, painter, x, y): 
        painter.drawPolygon(QPolygonF([QPointF(x,y-24),QPointF(x-12,y-8),QPointF(x-6,y-8),QPointF(x-6,y+16),QPointF(x+6,y+16),QPointF(x+6,y-8),QPointF(x+12,y-8)]))
    def draw_mini_destination(self, painter, x, y):
        painter.setBrush(QBrush(QColor(HYUNDAI_COLORS['warning'])))
        painter.drawEllipse(QPointF(x,y), 16, 16)
        painter.setBrush(QBrush(QColor(HYUNDAI_COLORS['white_soft'])))
        painter.drawEllipse(QPointF(x,y), 6, 6)

    def draw_mini_exit_complete(self, painter, x, y):
        painter.setBrush(QBrush(QColor(HYUNDAI_COLORS['warning'])))
        painter.drawEllipse(QPointF(x,y), 16, 16)
        painter.setPen(QPen(QColor(HYUNDAI_COLORS['white_soft']), 4))
        painter.drawLine(QPointF(x-6, y), QPointF(x-2, y+4))
        painter.drawLine(QPointF(x-2, y+4), QPointF(x+6, y-4))

    def draw_decorative_elements(self, painter, rect):
        painter.save()
        painter.setBrush(QBrush(QColor(HYUNDAI_COLORS['gray_medium'])))
        painter.setPen(Qt.NoPen)
        painter.drawRect(0, 40, rect.width(), 4)
        painter.drawRect(0, rect.height()-44, rect.width(), 4)
        
        corner_size = 40
        painter.setPen(QPen(QColor(HYUNDAI_COLORS['blue_soft']), 4))
        painter.setBrush(Qt.NoBrush)
        painter.drawArc(30, 30, corner_size, corner_size, 90*16, 90*16)
        painter.drawArc(rect.width()-70, 30, corner_size, corner_size, 0*16, 90*16)
        painter.drawArc(30, rect.height()-70, corner_size, corner_size, 180*16, 90*16)
        painter.drawArc(rect.width()-70, rect.height()-70, corner_size, corner_size, 270*16, 90*16)
        painter.restore()

    def update_navigation_info(self, instructions, current_speed=0, route_progress=0):
        self.speed, self.progress = current_speed, route_progress
        if not instructions:
            self.current_direction, self.current_distance, self.next_direction = "ê²½ë¡œë¥¼ ìƒì„±í•˜ì„¸ìš”", 0.0, ""
            self.update()
            return

        direction, distance = instructions[0]
        
        # íšŒì „ ì™„ë£Œ íŒë‹¨: 2m ì´ë‚´ë¡œ ë‚¨ì•˜ì„ ë•Œ íšŒì „ì„ ì™„ë£Œí–ˆë‹¤ê³  ì¸ì§€
        is_turn_complete = ("ì¢ŒíšŒì „" in direction or "ìš°íšŒì „" in direction) and distance <= 2

        # ëª©ì ì§€ ë„ì°© íŒë‹¨: ì˜¤ì§ instructions[0]ì´ "ëª©ì ì§€ ë„ì°©" ë˜ëŠ” "ì¶œì°¨ ì™„ë£Œ"ì¼ ë•Œë§Œ
        # ì„œë²„ë¡œë¶€í„° ì „ì†¡ë°›ì€ ë§ˆì§€ë§‰ ì¢Œí‘œ ê·¼ì²˜ë¡œ ê°”ì„ ë•Œ generate_hud_instructionsê°€
        # instructions[0]ì— "ëª©ì ì§€ ë„ì°©"ì„ ìƒì„±í•˜ë¯€ë¡œ, ì´ê²ƒë§Œ í™•ì¸í•˜ë©´ ë¨
        is_destination_arrival = (
            ("ëª©ì ì§€" in direction or "ë„ì°©" in direction or "ì¶œì°¨ ì™„ë£Œ" in direction) and 
            distance <= 5
        )

        if is_destination_arrival:
            # ëª©ì ì§€ ë„ì°©: instructions[0]ì´ ëª©ì ì§€ ë„ì°©ì´ê³  ê±°ë¦¬ê°€ 5m ì´í•˜
            # ê±°ë¦¬ëŠ” 1m ì´í•˜ë©´ 0ìœ¼ë¡œ ì´ë¯¸ ê³ ì •ë˜ì–´ ìˆìŒ
            self.current_direction = direction
            self.current_distance = distance if distance > 1.0 else 0.0
            self.next_direction = ""
        elif is_turn_complete and len(instructions) > 1:
            # íšŒì „ ì™„ë£Œ: ë‹¤ìŒ ì•ˆë‚´ë¡œ ë„˜ì–´ê°
            next_dir, next_dist = instructions[1]
            
            # Smart_Parking_GUI.py ë¡œì§ ì°¸ê³ : ë‹¤ìŒì´ ëª©ì ì§€/ì¶œì°¨ ì™„ë£Œì´ê³  ê±°ë¦¬ê°€ 8më³´ë‹¤ í¬ë©´ ì§ì§„ í‘œì‹œ
            # ëª©ì ì§€ ë„ì°©/ì¶œì°¨ ì™„ë£ŒëŠ” instructions[0]ì¼ ë•Œë§Œ í‘œì‹œí•˜ë¯€ë¡œ,
            # íšŒì „ ì™„ë£Œ í›„ì—ëŠ” ë‹¤ìŒ ì•ˆë‚´ê°€ ëª©ì ì§€/ì¶œì°¨ ì™„ë£Œì—¬ë„ ê±°ë¦¬ê°€ 8më³´ë‹¤ í¬ë©´ ì§ì§„ìœ¼ë¡œ í‘œì‹œ
            if (("ëª©ì ì§€" in next_dir or "ë„ì°©" in next_dir or "ì¶œì°¨ ì™„ë£Œ" in next_dir) and next_dist > 8):
                # ëª©ì ì§€/ì¶œì°¨ ì™„ë£Œê¹Œì§€ ê±°ë¦¬ê°€ 8më³´ë‹¤ í¬ë©´ ì§ì§„ í‘œì‹œ
                self.current_direction = "ì§ì§„"
                self.current_distance = next_dist
                self.next_direction = next_dir
            elif (("ëª©ì ì§€" in next_dir or "ë„ì°©" in next_dir or "ì¶œì°¨ ì™„ë£Œ" in next_dir) and next_dist <= 8):
                # ëª©ì ì§€/ì¶œì°¨ ì™„ë£Œê¹Œì§€ ê±°ë¦¬ê°€ 8m ì´í•˜ì´ì§€ë§Œ, ë„ì°©/ì™„ë£ŒëŠ” instructions[0]ì¼ ë•Œë§Œ í‘œì‹œ
                # ë”°ë¼ì„œ ì—¬ê¸°ì„œëŠ” ì§ì§„ìœ¼ë¡œ í‘œì‹œí•˜ê³  ë‹¤ìŒ ì•ˆë‚´ëŠ” ëª©ì ì§€/ì¶œì°¨ ì™„ë£Œ
                self.current_direction = "ì§ì§„"
                self.current_distance = next_dist
                self.next_direction = next_dir
            else:
                # ë‹¤ìŒ ì•ˆë‚´ê°€ ì§ì§„ ë“± ì¼ë°˜ ì•ˆë‚´ì¸ ê²½ìš°
                self.current_direction = next_dir
                self.current_distance = next_dist
                if len(instructions) > 2:
                    self.next_direction = instructions[2][0]
                else:
                    self.next_direction = ""
        else:
            # íšŒì „ ì „í™˜ ì‹œì : 8m ì´ë‚´ë¡œ ë‚¨ì•˜ì„ ë•Œ íšŒì „ ì•ˆë‚´ ì‹œì‘
            if ("ì¢ŒíšŒì „" in direction or "ìš°íšŒì „" in direction):
                if distance > 8:
                    # 8më³´ë‹¤ ë©€ë¦¬ ìˆìœ¼ë©´ ì§ì§„ í‘œì‹œ, ë‹¤ìŒ ì•ˆë‚´ëŠ” íšŒì „
                    self.current_direction = "ì§ì§„"
                    self.current_distance = distance
                    self.next_direction = direction
                else:
                    # 8m ì´ë‚´ë¡œ ì§„ì…í•˜ë©´ íšŒì „ ì•ˆë‚´ í‘œì‹œ
                    # ìš°íšŒì „ ì¤‘ì—ëŠ” ëª©ì ì§€ ë„ì°©ìœ¼ë¡œ ë„˜ì–´ê°€ì§€ ì•ŠìŒ
                    self.current_direction = direction
                    self.current_distance = distance
                    # ë‹¤ìŒ ì•ˆë‚´ ì„¤ì • (ë‹¤ìŒ ì•ˆë‚´ê°€ ëª©ì ì§€ì—¬ë„ íšŒì „ ì¤‘ì—ëŠ” ë„˜ì–´ê°€ì§€ ì•ŠìŒ)
                    if len(instructions) > 1:
                        next_dir, next_dist = instructions[1]
                        self.next_direction = next_dir
                    else:
                        self.next_direction = ""
            else:
                # ì§ì§„ ë“± (íšŒì „ì´ ì•„ë‹Œ ê²½ìš°)
                if distance > 5:
                    self.current_direction = "ì§ì§„"
                    self.current_distance = distance
                    self.next_direction = direction if direction != "ì§ì§„" else ""
                else:
                    self.current_direction = direction
                    self.current_distance = distance
                    if len(instructions) > 1:
                        next_dir, next_dist = instructions[1]
                        self.next_direction = next_dir
                    else:
                        self.next_direction = ""

        new_direction = self.current_direction
        if new_direction != self.target_direction:
            self.previous_direction, self.target_direction, self.direction_transition = self.target_direction, new_direction, 0.0
            
            self.play_voice_guidance(new_direction, self.current_distance)

        self.update()
    
    def play_voice_guidance(self, direction, distance):
        """ìŒì„± ì•ˆë‚´ ë©”ì‹œì§€ ìƒì„± ë° ì¬ìƒ"""
        if not direction or direction == "ê²½ë¡œ ì„¤ì • ëŒ€ê¸°":
            return
        
        voice_message = self.generate_voice_message(direction, distance)
        
        if voice_message:
            self.voice_guide.speak_instruction(voice_message)
    
    def generate_voice_message(self, direction, distance):
        """ë°©í–¥ê³¼ ê±°ë¦¬ì— ë”°ë¥¸ ìŒì„± ì•ˆë‚´ ë©”ì‹œì§€ ìƒì„± (í•œêµ­ì–´)"""
        distance_int = int(round(distance))
        
        if "ì¢ŒíšŒì „" in direction:
            if distance_int <= 0:
                return "ì§€ê¸ˆ ì¢ŒíšŒì „í•˜ì„¸ìš”"
            else:
                return f"{distance_int}ë¯¸í„° í›„ ì¢ŒíšŒì „ì…ë‹ˆë‹¤"
        elif "ìš°íšŒì „" in direction:
            if distance_int <= 0:
                return "ì§€ê¸ˆ ìš°íšŒì „í•˜ì„¸ìš”"
            else:
                return f"{distance_int}ë¯¸í„° í›„ ìš°íšŒì „ì…ë‹ˆë‹¤"
        elif "ì§ì§„" in direction:
            if distance_int <= 0:
                return "ì§€ê¸ˆ ì§ì§„í•˜ì„¸ìš”"
            else:
                return f"{distance_int}ë¯¸í„° ì§ì§„ì…ë‹ˆë‹¤"
        elif "ëª©ì ì§€ ë„ì°©" in direction:
            return "ëª©ì ì§€ì— ë„ì°©í–ˆìŠµë‹ˆë‹¤"
        elif "ì¶œì°¨ ì™„ë£Œ" in direction:
            return "ì¶œì°¨ê°€ ì™„ë£Œë˜ì—ˆìŠµë‹ˆë‹¤"
        elif "ì¶œì°¨" in direction:
            if "ì¢ŒíšŒì „" in direction:
                if distance_int <= 0:
                    return "ì§€ê¸ˆ ì¶œì°¨ ì¢ŒíšŒì „í•˜ì„¸ìš”"
                else:
                    return f"{distance_int}ë¯¸í„° í›„ ì¶œì°¨ ì¢ŒíšŒì „ì…ë‹ˆë‹¤"
            elif "ìš°íšŒì „" in direction:
                if distance_int <= 0:
                    return "ì§€ê¸ˆ ì¶œì°¨ ìš°íšŒì „í•˜ì„¸ìš”"
                else:
                    return f"{distance_int}ë¯¸í„° í›„ ì¶œì°¨ ìš°íšŒì „ì…ë‹ˆë‹¤"
            else:
                if distance_int <= 0:
                    return "ì§€ê¸ˆ ì¶œì°¨ ì§ì§„í•˜ì„¸ìš”"
                else:
                    return f"{distance_int}ë¯¸í„° ì¶œì°¨ ì§ì§„ì…ë‹ˆë‹¤"
        else:
            if distance_int <= 0:
                return f"ì§€ê¸ˆ {direction}í•˜ì„¸ìš”"
            else:
                return f"{distance_int}ë¯¸í„° í›„ {direction}ì…ë‹ˆë‹¤"

    def start_exit_scenario(self):
        """ì¶œì°¨ ì‹œë‚˜ë¦¬ì˜¤ ì‹œì‘ - Smart_Parking_GUI.py ë¡œì§ ì°¸ê³ """
        # ë¶€ëª¨ ìœ„ì ¯(NavigationHUD)ì˜ ì¶œì°¨ ì‹œë‚˜ë¦¬ì˜¤ ë©”ì„œë“œ í˜¸ì¶œ
        if hasattr(self.parent(), 'start_exit_scenario'):
            self.parent().start_exit_scenario()

# ===================================================================
# HUD ë©”ì¸ UI í´ë˜ìŠ¤
# ===================================================================
class NavigationHUD(QWidget):
    """HUD ë„¤ë¹„ê²Œì´ì…˜ ë©”ì¸ UI"""
    
    def __init__(self):
        super().__init__()
        self.zmq_receiver = None
        self.hud_widget = PremiumHudWidget(self)  # parent ì„¤ì •í•˜ì—¬ start_exit_scenario ì ‘ê·¼ ê°€ëŠ¥
        self.last_position = None  # ë§ˆì§€ë§‰ ì°¨ëŸ‰ ìœ„ì¹˜ ì €ì¥
        self.current_parking_spot = None  # í˜„ì¬ ì£¼ì°¨ êµ¬ì—­ ë²ˆí˜¸
        self.payment_waiting_dialog = None  # ì •ì‚° ëŒ€ê¸° íŒì—…
        self.pending_parking_spot = None  # ì •ì‚° ëŒ€ê¸° ì¤‘ì¸ ì£¼ì°¨ êµ¬ì—­
        
        self.init_ui()
        self.setup_zmq_receiver()
        
    def init_ui(self):
        """UI ì´ˆê¸°í™”"""
        self.setWindowTitle("SmartParking Navigation System - HUD (ì¹´ë©”ë¼ ë°°ê²½)")
        
        # ìµœëŒ€í™”/ìµœì†Œí™” ë²„íŠ¼ í™œì„±í™”
        self.setWindowFlags(Qt.Window | Qt.WindowMinimizeButtonHint | Qt.WindowMaximizeButtonHint | Qt.WindowCloseButtonHint)
        
        # ì¹´ë©”ë¼ ë°°ê²½ ë ˆì´ë¸” ìƒì„± (ì „ì²´ í™”ë©´)
        self.camera_label = QLabel(self)
        self.camera_label.setAlignment(Qt.AlignCenter)
        self.camera_label.setText("ESP32 ì¹´ë©”ë¼ ì—°ê²° ì¤‘...")
        self.camera_label.setStyleSheet("color: white; font-size: 18px; background-color: #1a1a1a;")
        self.camera_label.setScaledContents(True)  # ì „ì²´ í™”ë©´ ì±„ìš°ê¸°
        self.camera_label.setGeometry(0, 0, self.width() if self.width() > 0 else 1920, self.height() if self.height() > 0 else 1080)
        
        # HUD ìœ„ì ¯ì„ ì˜¤ë²„ë ˆì´ë¡œ ë°°ì¹˜ (íˆ¬ëª… ë°°ê²½)
        # ë¶€ëª¨ë¥¼ selfë¡œ ì„¤ì •í•˜ê³  absolute positionìœ¼ë¡œ ë°°ì¹˜
        self.hud_widget.setParent(self)
        # ì°½ì´ í‘œì‹œëœ í›„ í¬ê¸°ë¥¼ ì„¤ì •í•˜ë„ë¡ íƒ€ì´ë¨¸ ì‚¬ìš©
        QTimer.singleShot(100, self.update_hud_geometry)
        
        self.setStyleSheet(f"""
            QWidget {{
                background: {HYUNDAI_COLORS['background']};
                color: {HYUNDAI_COLORS['text_primary']};
            }}
        """)
        
        # HUD ìœ„ì ¯ì´ ì•ì— í‘œì‹œë˜ë„ë¡ raise
        self.hud_widget.raise_()
        
        # ì¹´ë©”ë¼ ìŠ¤íŠ¸ë¦¼ ìŠ¤ë ˆë“œ ì‹œì‘
        self.video_thread = VideoThread(ESP32_CAM_URL)
        self.video_thread.change_pixmap_signal.connect(self.update_camera_image)
        self.video_thread.connection_status_signal.connect(self.update_camera_status)
        self.video_thread.start()
    
    def showEvent(self, event):
        """ì°½ì´ í‘œì‹œë  ë•Œ HUD ìœ„ì ¯ í¬ê¸° ì—…ë°ì´íŠ¸"""
        super().showEvent(event)
        QTimer.singleShot(50, self.update_hud_geometry)
    
    def update_hud_geometry(self):
        """HUD ìœ„ì ¯ì˜ í¬ê¸°ì™€ ìœ„ì¹˜ ì—…ë°ì´íŠ¸"""
        if hasattr(self, 'hud_widget'):
            width = self.width() if self.width() > 0 else 1920
            height = self.height() if self.height() > 0 else 1080
            self.hud_widget.setGeometry(0, 0, width, height)
            self.hud_widget.raise_()  # í•­ìƒ ì•ì— í‘œì‹œ
            self.hud_widget.show()  # ëª…ì‹œì ìœ¼ë¡œ í‘œì‹œ
            self.hud_widget.update()  # ë‹¤ì‹œ ê·¸ë¦¬ê¸°
    
    def resizeEvent(self, event):
        """ì°½ í¬ê¸° ë³€ê²½ ì‹œ ì¹´ë©”ë¼ ë ˆì´ë¸”ê³¼ HUD ìœ„ì ¯ë„ í•¨ê»˜ ë¦¬ì‚¬ì´ì¦ˆ"""
        super().resizeEvent(event)
        width = self.width()
        height = self.height()
        
        # ì¹´ë©”ë¼ ë ˆì´ë¸” í¬ê¸° ì—…ë°ì´íŠ¸
        if hasattr(self, 'camera_label'):
            self.camera_label.setGeometry(0, 0, width, height)
        
        # HUD ìœ„ì ¯ í¬ê¸° ì—…ë°ì´íŠ¸
        if hasattr(self, 'hud_widget'):
            self.hud_widget.setGeometry(0, 0, width, height)
            self.hud_widget.raise_()  # í•­ìƒ ì•ì— í‘œì‹œ
            self.hud_widget.update()  # ë‹¤ì‹œ ê·¸ë¦¬ê¸°
    
    def update_camera_image(self, qt_image):
        """ì¹´ë©”ë¼ ì´ë¯¸ì§€ ì—…ë°ì´íŠ¸"""
        try:
            if hasattr(self, 'camera_label') and self.camera_label.isVisible():
                # ì „ì²´ í™”ë©´ì„ ì±„ìš°ë„ë¡ ìŠ¤ì¼€ì¼ë§
                label_size = self.camera_label.size()
                if label_size.width() > 0 and label_size.height() > 0:
                    scaled_pixmap = QPixmap.fromImage(qt_image).scaled(
                        label_size, 
                        Qt.KeepAspectRatioByExpanding, 
                        Qt.SmoothTransformation
                    )
                    self.camera_label.setPixmap(scaled_pixmap)
        except Exception as e:
            print(f"âš ï¸ ì¹´ë©”ë¼ ì´ë¯¸ì§€ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")
    
    def update_camera_status(self, status):
        """ì¹´ë©”ë¼ ì—°ê²° ìƒíƒœ ì—…ë°ì´íŠ¸"""
        if status != "ì—°ê²°ë¨":
            self.camera_label.setText(f"ì¹´ë©”ë¼ ìƒíƒœ: {status}")
        print(f"ğŸ“¹ ì¹´ë©”ë¼ ìƒíƒœ: {status}")
        
    def setup_zmq_receiver(self):
        """ZeroMQ ìˆ˜ì‹ ê¸° ì„¤ì •"""
        self.zmq_receiver = HUDDataReceiver()
        
        self.zmq_receiver.position_received.connect(self.on_position_received)
        self.zmq_receiver.navigation_received.connect(self.on_navigation_received)
        self.zmq_receiver.waypoint_received.connect(self.on_waypoint_received)
        self.zmq_receiver.payment_received.connect(self.on_payment_received)  # ì •ì‚° ë°ì´í„° ìˆ˜ì‹  ì—°ê²°
        
        if self.zmq_receiver.start():
            print("âœ… HUD ZeroMQ ì—°ê²° ì„±ê³µ")
        else:
            print("âŒ HUD ZeroMQ ì—°ê²° ì‹¤íŒ¨")
    
    def on_position_received(self, message_data):
        """ì°¨ëŸ‰ ìœ„ì¹˜ ë°ì´í„° ìˆ˜ì‹  ì²˜ë¦¬"""
        try:
            position_data = message_data.get('data', {})
            speed = position_data.get('speed', 0)
            
            # ì°¨ëŸ‰ ìœ„ì¹˜ ì €ì¥ (ì¶œì°¨ ì‹œë‚˜ë¦¬ì˜¤ì—ì„œ ì‚¬ìš©)
            if 'x' in position_data and 'y' in position_data:
                self.last_position = (position_data['x'], position_data['y'])
                # ì£¼ì°¨ êµ¬ì—­ ê°ì§€
                self.current_parking_spot = self.detect_parking_spot(self.last_position)
            
            # ì†ë„ëŠ” ë„¤ë¹„ê²Œì´ì…˜ ì•ˆë‚´ì—ì„œ í•¨ê»˜ ì—…ë°ì´íŠ¸ë¨
        except Exception as e:
            print(f"âŒ HUD ìœ„ì¹˜ ë°ì´í„° ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
    
    def on_navigation_received(self, message_data):
        """ë„¤ë¹„ê²Œì´ì…˜ ì•ˆë‚´ ë°ì´í„° ìˆ˜ì‹  ì²˜ë¦¬"""
        try:
            nav_data = message_data.get('data', {})
            instruction = nav_data.get('instruction', 'ì•ˆë‚´ ì—†ìŒ')
            distance = nav_data.get('distance', 0)
            action = nav_data.get('action', 'ê³„ì†')
            speed = nav_data.get('speed', 0)
            progress = nav_data.get('progress', 0)
            
            # HUD ì—…ë°ì´íŠ¸ (instructions í˜•ì‹ìœ¼ë¡œ ë³€í™˜)
            instructions = []
            if instruction and distance >= 0:
                instructions.append((instruction, distance))
            
            # ë‹¤ìŒ ì•ˆë‚´ê°€ ìˆìœ¼ë©´ ì¶”ê°€
            if nav_data.get('next_instruction'):
                instructions.append((nav_data.get('next_instruction'), nav_data.get('next_distance', 0)))
            
            self.hud_widget.update_navigation_info(instructions, current_speed=speed, route_progress=progress)
            
        except Exception as e:
            print(f"âŒ HUD ë„¤ë¹„ê²Œì´ì…˜ ë°ì´í„° ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
    
    def on_waypoint_received(self, message_data):
        """ì›¨ì´í¬ì¸íŠ¸ ë°ì´í„° ìˆ˜ì‹  ì²˜ë¦¬"""
        try:
            waypoint_data = message_data.get('data', {})
            waypoints = waypoint_data.get('waypoints', [])
            
            # ì¬í• ë‹¹ëœ ê²½ë¡œì¸ì§€ í™•ì¸ (parking_topview.pyì™€ ë™ì¼í•œ ë¡œì§)
            is_reassignment = (
                message_data.get('type') == 'waypoint_reassignment' or 
                waypoint_data.get('type') == 'waypoint_reassignment' or
                waypoint_data.get('assignment_mode') == 'test_reassignment'
            )
            
            # ê²½ë¡œ ì „ì†¡ ë°›ìœ¼ë©´ ìŒì„± ì•ˆë‚´
            if waypoints:
                if is_reassignment:
                    # ì¬í• ë‹¹ëœ ê²½ë¡œì¼ ë•ŒëŠ” ë‹¤ë¥¸ ë©”ì‹œì§€
                    self.hud_widget.voice_guide.speak_instruction("ê²½ë¡œë¥¼ ì´íƒˆí•˜ì—¬ ì¬íƒìƒ‰ í•©ë‹ˆë‹¤")
                    print(f"ğŸ§­ HUD ì›¨ì´í¬ì¸íŠ¸ ì—…ë°ì´íŠ¸: {len(waypoints)}ê°œ í¬ì¸íŠ¸ (ì¬í• ë‹¹)")
                    print(f"ğŸ“¢ ê²½ë¡œë¥¼ ì´íƒˆí•˜ì—¬ ì¬íƒìƒ‰ í•©ë‹ˆë‹¤")
                else:
                    # ì¼ë°˜ ê²½ë¡œì¼ ë•ŒëŠ” ê¸°ì¡´ ë©”ì‹œì§€
                    self.hud_widget.voice_guide.speak_instruction("ê²½ë¡œ ì•ˆë‚´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤")
                    print(f"ğŸ§­ HUD ì›¨ì´í¬ì¸íŠ¸ ì—…ë°ì´íŠ¸: {len(waypoints)}ê°œ í¬ì¸íŠ¸")
                    print(f"ğŸ“¢ ê²½ë¡œ ì•ˆë‚´ë¥¼ ì‹œì‘í•©ë‹ˆë‹¤")
        except Exception as e:
            print(f"âŒ HUD ì›¨ì´í¬ì¸íŠ¸ ë°ì´í„° ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
    
    def on_payment_received(self, message_data):
        """ì •ì‚° ê¸ˆì•¡ ë°ì´í„° ìˆ˜ì‹  ì²˜ë¦¬"""
        try:
            payment_data = message_data.get('data', {})
            amount = payment_data.get('amount', 0)
            
            # ì •ì‚° í™•ì¸ íŒì—… í‘œì‹œ
            self.show_payment_confirmation(amount)
            
        except Exception as e:
            print(f"âŒ HUD ì •ì‚° ë°ì´í„° ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
    
    def detect_parking_spot(self, car_pos):
        """ì°¨ëŸ‰ ìœ„ì¹˜ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì£¼ì°¨ êµ¬ì—­ ë²ˆí˜¸ ê°ì§€ - Smart_Parking_GUI.py ë¡œì§ ì°¸ê³ """
        x, y = car_pos[0], car_pos[1]
        
        # ì£¼ì°¨ êµ¬ì—­ë³„ ì¢Œí‘œ ë²”ìœ„ ì •ì˜ (Smart_Parking_GUI.pyì™€ ë™ì¼)
        parking_spots = {
            # 1~5ë²ˆ ì£¼ì°¨êµ¬ì—­ (ìƒë‹¨ ì£¼ì°¨êµ¬ì—­)
            1: (0, 1600, 400, 400),      # ì¥ì• ì¸ êµ¬ì—­
            2: (400, 1600, 300, 400),    # ì¼ë°˜ êµ¬ì—­
            3: (700, 1600, 300, 400),    # ì¼ë°˜ êµ¬ì—­
            4: (1000, 1600, 300, 400),   # ì „ê¸°ì°¨ êµ¬ì—­
            5: (1300, 1600, 300, 400),   # ì „ê¸°ì°¨ êµ¬ì—­
            
            # 6~7ë²ˆ ì£¼ì°¨êµ¬ì—­ (ìš°ì¸¡ ì£¼ì°¨êµ¬ì—­)
            6: (1600, 1200, 400, 400),   # ì¥ì• ì¸ êµ¬ì—­
            7: (1600, 800, 400, 400),    # ì¥ì• ì¸ êµ¬ì—­
            
            # 8~11ë²ˆ ì£¼ì°¨êµ¬ì—­ (í•˜ë‹¨ ì£¼ì°¨êµ¬ì—­)
            8: (1300, 400, 300, 400),    # ì¼ë°˜ êµ¬ì—­
            9: (1000, 400, 300, 400),    # ì¼ë°˜ êµ¬ì—­
            10: (700, 400, 300, 400),    # ì „ê¸°ì°¨ êµ¬ì—­
            11: (400, 400, 300, 400),     # ì „ê¸°ì°¨ êµ¬ì—­
        }
        
        for spot_num, (spot_x, spot_y, spot_w, spot_h) in parking_spots.items():
            if spot_x <= x <= spot_x + spot_w and spot_y <= y <= spot_y + spot_h:
                return spot_num
        
        return None
    
    def generate_exit_waypoints(self, parking_spot):
        """ì¶œì°¨ ì›¨ì´í¬ì¸íŠ¸ ìƒì„± - Smart_Parking_GUI.py ë¡œì§ ì°¸ê³ 
        ì£¼ì°¨ ì¢Œí‘œ í¬ì¸íŠ¸ë¶€í„° ì‹œì‘í•˜ëŠ” ì „ì²´ ì¶œì°¨ ê²½ë¡œë¥¼ ë°˜í™˜"""
        MANDATORY_WAYPOINT = [200, 925]
        FINAL_DESTINATION = [200, 200]  # ìµœì¢… ëª©ì ì§€ (ì…êµ¬)
        
        # ì£¼ì°¨êµ¬ì—­ë³„ ì‹œì‘ ì¢Œí‘œ (Smart_Parking_GUI.pyì˜ get_parking_spot_start_waypointì™€ ë™ì¼)
        parking_waypoints = {
            # ì£¼ì°¨êµ¬ì—­ 1-5 (ìƒë‹¨, ì™¼ìª½â†’ì˜¤ë¥¸ìª½)
            1: [200, 1475], 2: [550, 1475], 3: [850, 1475], 4: [1150, 1475],
            5: [1450, 1475],
            # ì£¼ì°¨êµ¬ì—­ 6-7 (ìš°ì¸¡, ìœ„â†’ì•„ë˜)  
            6: [1475, 1400], 7: [1475, 1000],
            # ì£¼ì°¨êµ¬ì—­ 8-11 (í•˜ë‹¨, ì˜¤ë¥¸ìª½â†’ì™¼ìª½)
            8: [1475, 925], 9: [1150, 925], 10: [850, 925], 11: [550, 925]
        }
        
        current_waypoint = parking_waypoints.get(parking_spot)
        if not current_waypoint:
            return None
        
        exit_waypoints = []
        
        # Smart_Parking_GUI.pyì˜ calculate_and_display_exit_routeì²˜ëŸ¼ ì£¼ì°¨ ì¢Œí‘œ í¬ì¸íŠ¸ë¶€í„° ì‹œì‘
        # ì „ì²´ ê²½ë¡œ: [ì£¼ì°¨ ì¢Œí‘œ í¬ì¸íŠ¸] + [ì¤‘ê°„ ì›¨ì´í¬ì¸íŠ¸ë“¤] + [ìµœì¢… ëª©ì ì§€]
        
        if parking_spot == 1:  # 1ë²ˆ: (200,1475) -> (200,925) -> (200,200)
            exit_waypoints.append(current_waypoint)  # [200, 1475]ë¶€í„° ì‹œì‘
            exit_waypoints.append(MANDATORY_WAYPOINT)
            exit_waypoints.append(FINAL_DESTINATION)
        elif parking_spot in [2, 3, 4, 5]:  # 2~5ë²ˆ: ì£¼ì°¨ ì¢Œí‘œ -> (200, 1475) -> (200, 925) -> (200,200)
            exit_waypoints.append(current_waypoint)  # ì£¼ì°¨ ì¢Œí‘œë¶€í„° ì‹œì‘
            exit_waypoints.append([200, 1475])
            exit_waypoints.append(MANDATORY_WAYPOINT)
            exit_waypoints.append(FINAL_DESTINATION)
        elif parking_spot == 6:  # 6ë²ˆ: (1475, 1400) -> (1475, 1475) -> (200, 1475) -> (200, 925) -> (200,200)
            exit_waypoints.append(current_waypoint)  # [1475, 1400]ë¶€í„° ì‹œì‘
            exit_waypoints.append([1475, 1475])
            exit_waypoints.append([200, 1475])
            exit_waypoints.append(MANDATORY_WAYPOINT)
            exit_waypoints.append(FINAL_DESTINATION)
        elif parking_spot == 7:  # 7ë²ˆ: (1475, 1000) -> (1475, 925) -> (200, 925) -> (200,200)
            exit_waypoints.append(current_waypoint)  # [1475, 1000]ë¶€í„° ì‹œì‘
            exit_waypoints.append([1475, 925])
            exit_waypoints.append(MANDATORY_WAYPOINT)
            exit_waypoints.append(FINAL_DESTINATION)
        elif parking_spot in [8, 9, 10, 11]:  # 8~11ë²ˆ: ì£¼ì°¨ ì¢Œí‘œ -> (200, 925) -> (200,200)
            exit_waypoints.append(current_waypoint)  # ì£¼ì°¨ ì¢Œí‘œë¶€í„° ì‹œì‘
            exit_waypoints.append(MANDATORY_WAYPOINT)
            exit_waypoints.append(FINAL_DESTINATION)
        
        return exit_waypoints
    
    def start_exit_scenario(self):
        """ì¶œì°¨ ì‹œë‚˜ë¦¬ì˜¤ ì‹œì‘ - ì •ì‚° ì²˜ë¦¬ í›„ ì¶œì°¨ ë¡œì§ ì‹œì‘"""
        from PyQt5.QtWidgets import QMessageBox, QDialog, QVBoxLayout, QLabel, QPushButton, QDialogButtonBox
        import socket
        
        if self.last_position is None:
            QMessageBox.warning(self, "ì¶œì°¨ ì˜¤ë¥˜", "ì°¨ëŸ‰ ìœ„ì¹˜ ì •ë³´ê°€ ì—†ìŠµë‹ˆë‹¤. ë¨¼ì € ê²½ë¡œë¥¼ ì„¤ì •í•´ì£¼ì„¸ìš”.")
            return
        
        parking_spot = self.current_parking_spot
        if parking_spot is None:
            QMessageBox.warning(self, "ì¶œì°¨ ì˜¤ë¥˜", "í˜„ì¬ ìœ„ì¹˜ì—ì„œ ì£¼ì°¨ êµ¬ì—­ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            return
        
        # ì£¼ì°¨ êµ¬ì—­ ì €ì¥ (ì •ì‚° ì‘ë‹µ ëŒ€ê¸° ì¤‘)
        self.pending_parking_spot = parking_spot
        
        # 1ë‹¨ê³„: ì„œë²„ì— "pay" ëª…ë ¹ ì „ì†¡
        try:
            client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            client_socket.settimeout(5.0)
            client_socket.connect(('localhost', 9999))
            
            # "pay" ëª…ë ¹ì„ JSON í˜•ì‹ìœ¼ë¡œ ì „ì†¡
            pay_command = {
                'type': 'pay',
                'parking_spot': parking_spot
            }
            
            json_str = json.dumps(pay_command, ensure_ascii=False)
            client_socket.sendall(json_str.encode('utf-8'))
            time.sleep(0.01)
            client_socket.close()
            
            print(f"ğŸ’° ì •ì‚° ìš”ì²­ ì „ì†¡: ì£¼ì°¨êµ¬ì—­ {parking_spot}ë²ˆ")
            
            # 2ë‹¨ê³„: "ì •ì‚° ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤." íŒì—… í‘œì‹œ
            self.show_payment_waiting_dialog()
            
        except socket.timeout:
            QMessageBox.warning(self, "ì¶œì°¨ ì˜¤ë¥˜", "ì„œë²„ ì—°ê²° ì‹œê°„ ì´ˆê³¼. main_controller.pyê°€ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.")
            print(f"âŒ ì •ì‚° ìš”ì²­ ì‹¤íŒ¨: ì—°ê²° ì‹œê°„ ì´ˆê³¼")
        except ConnectionRefusedError:
            QMessageBox.warning(self, "ì¶œì°¨ ì˜¤ë¥˜", "ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. main_controller.pyê°€ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.")
            print(f"âŒ ì •ì‚° ìš”ì²­ ì‹¤íŒ¨: ì—°ê²° ê±°ë¶€ë¨")
        except Exception as e:
            QMessageBox.warning(self, "ì¶œì°¨ ì˜¤ë¥˜", f"ì •ì‚° ìš”ì²­ ì „ì†¡ ì‹¤íŒ¨: {e}")
            print(f"âŒ ì •ì‚° ìš”ì²­ ì‹¤íŒ¨: {e}")
    
    def show_payment_waiting_dialog(self):
        """ì •ì‚° ì²˜ë¦¬ ëŒ€ê¸° ì¤‘ íŒì—… í‘œì‹œ"""
        from PyQt5.QtWidgets import QDialog, QVBoxLayout, QLabel
        
        if self.payment_waiting_dialog:
            return
        
        self.payment_waiting_dialog = QDialog(self)
        self.payment_waiting_dialog.setWindowTitle("ì •ì‚° ì²˜ë¦¬ ì¤‘")
        self.payment_waiting_dialog.setModal(True)
        self.payment_waiting_dialog.setFixedSize(400, 150)
        
        layout = QVBoxLayout(self.payment_waiting_dialog)
        label = QLabel("ì •ì‚° ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤.")
        label.setAlignment(Qt.AlignCenter)
        label.setStyleSheet("font-size: 18px; font-weight: bold; color: #4a9eff;")
        layout.addWidget(label)
        
        self.payment_waiting_dialog.show()
    
    def close_payment_waiting_dialog(self):
        """ì •ì‚° ì²˜ë¦¬ ëŒ€ê¸° íŒì—… ë‹«ê¸°"""
        if self.payment_waiting_dialog:
            self.payment_waiting_dialog.close()
            self.payment_waiting_dialog = None
    
    def show_payment_confirmation(self, amount):
        """ì •ì‚° ê¸ˆì•¡ í™•ì¸ íŒì—… í‘œì‹œ"""
        from PyQt5.QtWidgets import QMessageBox
        
        # ì •ì‚° ì²˜ë¦¬ ëŒ€ê¸° íŒì—… ë‹«ê¸°
        self.close_payment_waiting_dialog()
        
        # ì •ì‚° í™•ì¸ íŒì—… í‘œì‹œ
        msg_box = QMessageBox(self)
        msg_box.setWindowTitle("ì£¼ì°¨ ì •ì‚°")
        msg_box.setText(f"ì£¼ì°¨ ì •ì‚° ê¸ˆì•¡: {amount:,}ì›\n\nì •ì‚°í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")
        msg_box.setStandardButtons(QMessageBox.Yes | QMessageBox.No)
        msg_box.button(QMessageBox.Yes).setText("YES")
        msg_box.button(QMessageBox.No).setText("NO")
        msg_box.setStyleSheet("""
            QMessageBox {
                background-color: #1a1a1a;
                color: white;
            }
            QLabel {
                color: white;
                font-size: 16px;
            }
            QPushButton {
                background-color: #4a9eff;
                color: white;
                border: none;
                padding: 10px 20px;
                border-radius: 5px;
                font-size: 14px;
                font-weight: bold;
            }
            QPushButton:hover {
                background-color: #6bb6ff;
            }
        """)
        
        result = msg_box.exec_()
        
        # ì„ íƒ ê²°ê³¼ë¥¼ ì„œë²„ì— ì „ì†¡
        payment_confirmed = (result == QMessageBox.Yes)
        self.send_payment_confirmation(payment_confirmed, amount)
    
    def send_payment_confirmation(self, confirmed, amount):
        """ì •ì‚° í™•ì¸ ê²°ê³¼ë¥¼ ì„œë²„ì— ì „ì†¡ í›„ ì¶œì°¨ ë¡œì§ ì‹œì‘"""
        import socket
        from PyQt5.QtWidgets import QMessageBox
        
        try:
            client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            client_socket.settimeout(5.0)
            client_socket.connect(('localhost', 9999))
            
            # ì •ì‚° í™•ì¸ ê²°ê³¼ë¥¼ JSON í˜•ì‹ìœ¼ë¡œ ì „ì†¡
            payment_result = {
                'type': 'payment_confirmation',
                'confirmed': confirmed,
                'amount': amount,
                'parking_spot': self.pending_parking_spot
            }
            
            json_str = json.dumps(payment_result, ensure_ascii=False)
            print(f"ğŸ“¤ ì •ì‚° í™•ì¸ ë°ì´í„° ì¤€ë¹„: {json_str}")
            
            client_socket.sendall(json_str.encode('utf-8'))
            print(f"âœ… ì •ì‚° í™•ì¸ ë°ì´í„° ì „ì†¡ ì™„ë£Œ ({len(json_str)} bytes)")
            
            # ì‘ë‹µ ëŒ€ê¸° (ì„ íƒì )
            try:
                client_socket.settimeout(1.0)
                response = client_socket.recv(1024).decode('utf-8')
                print(f"ğŸ“¥ ì„œë²„ ì‘ë‹µ: {response}")
            except socket.timeout:
                print(f"âš ï¸ ì„œë²„ ì‘ë‹µ ì—†ìŒ (íƒ€ì„ì•„ì›ƒ)")
            except:
                pass
            
            time.sleep(0.01)
            client_socket.close()
            
            print(f"ğŸ’° ì •ì‚° í™•ì¸ ì „ì†¡: {'í™•ì¸' if confirmed else 'ì·¨ì†Œ'}, ê¸ˆì•¡: {amount:,}ì›")
            
            # ì •ì‚°ì´ í™•ì¸ë˜ì—ˆì„ ë•Œë§Œ ì¶œì°¨ ë¡œì§ ì‹œì‘
            if confirmed and self.pending_parking_spot:
                self.start_exit_route()
            elif not confirmed:
                QMessageBox.information(self, "ì •ì‚° ì·¨ì†Œ", "ì •ì‚°ì´ ì·¨ì†Œë˜ì—ˆìŠµë‹ˆë‹¤.")
                self.pending_parking_spot = None
            
        except Exception as e:
            QMessageBox.warning(self, "ì •ì‚° ì˜¤ë¥˜", f"ì •ì‚° í™•ì¸ ì „ì†¡ ì‹¤íŒ¨: {e}")
            print(f"âŒ ì •ì‚° í™•ì¸ ì „ì†¡ ì‹¤íŒ¨: {e}")
            self.pending_parking_spot = None
    
    def start_exit_route(self):
        """ì¶œì°¨ ê²½ë¡œ ìƒì„± ë° ì „ì†¡ (ê¸°ì¡´ ë¡œì§)"""
        from PyQt5.QtWidgets import QMessageBox
        import socket
        
        parking_spot = self.pending_parking_spot
        if not parking_spot:
            return
        
        exit_waypoints = self.generate_exit_waypoints(parking_spot)
        if not exit_waypoints:
            QMessageBox.warning(self, "ì¶œì°¨ ì˜¤ë¥˜", "ì¶œì°¨ ê²½ë¡œë¥¼ ìƒì„±í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤.")
            self.pending_parking_spot = None
            return
        
        # TCP/IP ì†Œì¼“ìœ¼ë¡œ main_controller.pyì— ì¶œì°¨ ì›¨ì´í¬ì¸íŠ¸ ì „ì†¡
        try:
            client_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            client_socket.settimeout(5.0)
            client_socket.connect(('localhost', 9999))
            
            waypoint_data = {
                'type': 'waypoint',
                'waypoints': exit_waypoints,
                'parking_spot': parking_spot,
                'route_type': 'exit'
            }
            
            json_str = json.dumps(waypoint_data, ensure_ascii=False)
            client_socket.sendall(json_str.encode('utf-8'))
            time.sleep(0.01)
            client_socket.close()
            
            QMessageBox.information(self, "ì¶œì°¨ ì‹œë‚˜ë¦¬ì˜¤", 
                f"ì£¼ì°¨ êµ¬ì—­ {parking_spot}ë²ˆì—ì„œ ì¶œì°¨ ê²½ë¡œë¥¼ ì‹œì‘í•©ë‹ˆë‹¤.\nì…ì°¨ ê²½ë¡œì˜ ì—­ìˆœìœ¼ë¡œ ì•ˆì „í•˜ê²Œ ì¶œì°¨í•˜ì„¸ìš”.")
            print(f"ğŸš— ì¶œì°¨ ê²½ë¡œ ì „ì†¡ ì™„ë£Œ: ì£¼ì°¨êµ¬ì—­ {parking_spot}ë²ˆ, {len(exit_waypoints)}ê°œ ì›¨ì´í¬ì¸íŠ¸")
            print(f"   ì¶œì°¨ ê²½ë¡œ: {exit_waypoints}")
            
            self.pending_parking_spot = None
            
        except socket.timeout:
            QMessageBox.warning(self, "ì¶œì°¨ ì˜¤ë¥˜", "ì„œë²„ ì—°ê²° ì‹œê°„ ì´ˆê³¼. main_controller.pyê°€ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.")
            print(f"âŒ ì¶œì°¨ ê²½ë¡œ ì „ì†¡ ì‹¤íŒ¨: ì—°ê²° ì‹œê°„ ì´ˆê³¼")
            self.pending_parking_spot = None
        except ConnectionRefusedError:
            QMessageBox.warning(self, "ì¶œì°¨ ì˜¤ë¥˜", "ì„œë²„ì— ì—°ê²°í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤. main_controller.pyê°€ ì‹¤í–‰ ì¤‘ì¸ì§€ í™•ì¸í•´ì£¼ì„¸ìš”.")
            print(f"âŒ ì¶œì°¨ ê²½ë¡œ ì „ì†¡ ì‹¤íŒ¨: ì—°ê²° ê±°ë¶€ë¨")
            self.pending_parking_spot = None
        except Exception as e:
            QMessageBox.warning(self, "ì¶œì°¨ ì˜¤ë¥˜", f"ì¶œì°¨ ê²½ë¡œ ì „ì†¡ ì‹¤íŒ¨: {e}")
            print(f"âŒ ì¶œì°¨ ê²½ë¡œ ì „ì†¡ ì‹¤íŒ¨: {e}")
            self.pending_parking_spot = None
    
    def closeEvent(self, event):
        """ì°½ ë‹«ê¸° ì´ë²¤íŠ¸"""
        if hasattr(self, 'video_thread'):
            self.video_thread.stop()
        if self.zmq_receiver:
            self.zmq_receiver.stop()
        if self.hud_widget and hasattr(self.hud_widget, 'voice_guide'):
            self.hud_widget.voice_guide.stop()
        event.accept()

# ===================================================================
# ë©”ì¸ ì‹¤í–‰ë¶€
# ===================================================================
if __name__ == "__main__":
    print("=" * 60)
    print("ğŸ§­ Smart Parking System - HUD ë„¤ë¹„ê²Œì´ì…˜")
    print("=" * 60)
    
    QApplication.setAttribute(Qt.AA_EnableHighDpiScaling)
    QApplication.setAttribute(Qt.AA_UseHighDpiPixmaps)
    
    app = QApplication(sys.argv)
    app.setStyle('Fusion')
    
    font = QFont("Malgun Gothic", 10)
    app.setFont(font)
    
    app.setStyleSheet(f"""
        QApplication {{ background-color: '#303030'; }}
    """)
    
    hud_window = NavigationHUD()
    
    screens = app.screens()
    if len(screens) > 1:
        screen_geometry = screens[1].geometry()
        hud_window.setGeometry(screen_geometry)
        print(f"ğŸ–¥ï¸ ë‘ ë²ˆì§¸ ë””ìŠ¤í”Œë ˆì´ì— ë°°ì¹˜: {screen_geometry.width()}x{screen_geometry.height()}")
    elif len(screens) == 1:
        screen_geometry = screens[0].geometry()
        hud_window.setGeometry(screen_geometry)
        print(f"âš ï¸ ë””ìŠ¤í”Œë ˆì´ê°€ í•˜ë‚˜ë§Œ ê°ì§€ë¨. ì²« ë²ˆì§¸ ë””ìŠ¤í”Œë ˆì´ì— ë°°ì¹˜: {screen_geometry.width()}x{screen_geometry.height()}")
    
    hud_window.showMaximized()
    
    print("âœ… HUD ë„¤ë¹„ê²Œì´ì…˜ í™”ë©´ ì‹œì‘ë¨")
    print("ğŸ“¡ ë©”ì¸ ì»¨íŠ¸ë¡¤ëŸ¬ë¡œë¶€í„° ë°ì´í„° ìˆ˜ì‹  ëŒ€ê¸° ì¤‘...")
    
    sys.exit(app.exec_())
